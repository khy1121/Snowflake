/**\n * 원격 설정(Remote Config) 서비스\n * JSON 파일을 원격에서 로드하고 캐시\n */\n\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport interface RemoteConfigCache {\n  url: string;\n  data: Record<string, any>;\n  timestamp: number;\n  version: string;\n}\n\nconst CACHE_KEY_PREFIX = 'remote_config_';\nconst CACHE_DURATION_MS = 24 * 60 * 60 * 1000; // 24시간\nconst FETCH_TIMEOUT_MS = 10000; // 10초\nconst MAX_RETRIES = 2;\n\n/**\n * 원격 설정 서비스\n */\nexport class RemoteConfigService {\n  private static instance: RemoteConfigService;\n  private cache: Map<string, RemoteConfigCache> = new Map();\n  private fetchInProgress: Map<string, Promise<any>> = new Map();\n\n  private constructor() {}\n\n  static getInstance(): RemoteConfigService {\n    if (!RemoteConfigService.instance) {\n      RemoteConfigService.instance = new RemoteConfigService();\n    }\n    return RemoteConfigService.instance;\n  }\n\n  /**\n   * 원격 JSON 가져오기\n   */\n  async fetchRemoteJson<T = any>(\n    url: string,\n    options: { useCache?: boolean; forceRefresh?: boolean } = {}\n  ): Promise<T | null> {\n    const { useCache = true, forceRefresh = false } = options;\n\n    // 진행 중인 요청이 있으면 대기\n    if (this.fetchInProgress.has(url)) {\n      return this.fetchInProgress.get(url)!;\n    }\n\n    const promise = this._fetchWithRetry<T>(url, useCache, forceRefresh);\n    this.fetchInProgress.set(url, promise);\n\n    try {\n      const result = await promise;\n      return result;\n    } finally {\n      this.fetchInProgress.delete(url);\n    }\n  }\n\n  /**\n   * 재시도 로직이 포함된 가져오기\n   */\n  private async _fetchWithRetry<T>(\n    url: string,\n    useCache: boolean,\n    forceRefresh: boolean\n  ): Promise<T | null> {\n    // 캐시 확인\n    if (useCache && !forceRefresh) {\n      const cached = await this._loadFromCache<T>(url);\n      if (cached) {\n        console.log(`[RemoteConfig] Loaded from cache: ${url}`);\n        return cached;\n      }\n    }\n\n    // 원격 가져오기 시도\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {\n      try {\n        const data = await this._fetchWithTimeout<T>(url);\n        console.log(`[RemoteConfig] Successfully fetched: ${url}`);\n\n        // 캐시 저장\n        if (useCache) {\n          await this._saveToCache(url, data);\n        }\n\n        return data;\n      } catch (error) {\n        lastError = error as Error;\n        console.warn(\n          `[RemoteConfig] Fetch attempt ${attempt + 1} failed:`,\n          lastError.message\n        );\n\n        if (attempt < MAX_RETRIES) {\n          // 지수 백오프\n          const delay = Math.pow(2, attempt) * 1000;\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    console.error(`[RemoteConfig] Failed to fetch after ${MAX_RETRIES + 1} attempts:`, lastError);\n    return null;\n  }\n\n  /**\n   * 타임아웃이 포함된 가져오기\n   */\n  private async _fetchWithTimeout<T>(url: string): Promise<T> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);\n\n    try {\n      const response = await fetch(url, {\n        signal: controller.signal,\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      return data as T;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  /**\n   * 캐시에서 로드\n   */\n  private async _loadFromCache<T>(url: string): Promise<T | null> {\n    try {\n      const cacheKey = `${CACHE_KEY_PREFIX}${this._hashUrl(url)}`;\n      const cached = await AsyncStorage.getItem(cacheKey);\n\n      if (!cached) {\n        return null;\n      }\n\n      const cache: RemoteConfigCache = JSON.parse(cached);\n\n      // 캐시 만료 확인\n      if (Date.now() - cache.timestamp > CACHE_DURATION_MS) {\n        console.log(`[RemoteConfig] Cache expired: ${url}`);\n        await AsyncStorage.removeItem(cacheKey);\n        return null;\n      }\n\n      this.cache.set(url, cache);\n      return cache.data as T;\n    } catch (error) {\n      console.error('[RemoteConfig] Failed to load from cache:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 캐시에 저장\n   */\n  private async _saveToCache(url: string, data: any): Promise<void> {\n    try {\n      const cacheKey = `${CACHE_KEY_PREFIX}${this._hashUrl(url)}`;\n      const cache: RemoteConfigCache = {\n        url,\n        data,\n        timestamp: Date.now(),\n        version: '1.0',\n      };\n\n      await AsyncStorage.setItem(cacheKey, JSON.stringify(cache));\n      this.cache.set(url, cache);\n    } catch (error) {\n      console.error('[RemoteConfig] Failed to save to cache:', error);\n    }\n  }\n\n  /**\n   * URL 해시 (캐시 키 생성용)\n   */\n  private _hashUrl(url: string): string {\n    let hash = 0;\n    for (let i = 0; i < url.length; i++) {\n      const char = url.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // 32비트 정수로 변환\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * 캐시 초기화\n   */\n  async clearCache(url?: string): Promise<void> {\n    if (url) {\n      const cacheKey = `${CACHE_KEY_PREFIX}${this._hashUrl(url)}`;\n      await AsyncStorage.removeItem(cacheKey);\n      this.cache.delete(url);\n    } else {\n      // 모든 캐시 초기화\n      const keys = await AsyncStorage.getAllKeys();\n      const cacheKeys = keys.filter((k) => k.startsWith(CACHE_KEY_PREFIX));\n      await AsyncStorage.multiRemove(cacheKeys);\n      this.cache.clear();\n    }\n  }\n\n  /**\n   * 캐시 정보 조회\n   */\n  getCacheInfo(url: string): RemoteConfigCache | null {\n    return this.cache.get(url) || null;\n  }\n}\n\n/**\n * 싱글톤 인스턴스\n */\nexport const remoteConfigService = RemoteConfigService.getInstance();\n
