/**\n * 콘텐츠 팩 서비스\n * 원격으로 데이터 팩을 로드하고 검증, 머지, 캐시\n */\n\nimport { ContentPack, ContentPackMergeResult } from '../types';\n\n/**\n * 콘텐츠 팩 로드\n */\nexport async function loadContentPacks(\n  remoteConfigUrl: string,\n  appVersion: string,\n  timeout: number = 5000\n): Promise<{ packs: ContentPack[]; error?: string }> {\n  try {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    const response = await fetch(remoteConfigUrl, { signal: controller.signal });\n    clearTimeout(timeoutId);\n\n    if (!response.ok) {\n      return { packs: [], error: `HTTP ${response.status}` };\n    }\n\n    const data = await response.json();\n    const packs = data.contentPacks || [];\n\n    // 앱 버전 호환성 확인\n    const compatiblePacks = packs.filter((pack: ContentPack) => {\n      if (!pack.minAppVersion) return true;\n      return compareVersions(appVersion, pack.minAppVersion) >= 0;\n    });\n\n    return { packs: compatiblePacks };\n  } catch (error: any) {\n    return { packs: [], error: error.message };\n  }\n}\n\n/**\n * 콘텐츠 팩 검증\n */\nexport function validateContentPack(pack: ContentPack): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (!pack.id) errors.push('팩 ID 누락');\n  if (!pack.version) errors.push(`팩 버전 누락: ${pack.id}`);\n  if (!pack.checksum) errors.push(`팩 체크섬 누락: ${pack.id}`);\n\n  // 데이터 스키마 기본 검증\n  if (pack.data) {\n    if (pack.data.storyEpisodes && !Array.isArray(pack.data.storyEpisodes)) {\n      errors.push(`잘못된 스토리 에피소드 형식: ${pack.id}`);\n    }\n    if (pack.data.characters && !Array.isArray(pack.data.characters)) {\n      errors.push(`잘못된 캐릭터 형식: ${pack.id}`);\n    }\n    if (pack.data.events && !Array.isArray(pack.data.events)) {\n      errors.push(`잘못된 이벤트 형식: ${pack.id}`);\n    }\n  }\n\n  return { valid: errors.length === 0, errors };\n}\n\n/**\n * 콘텐츠 팩 머지\n */\nexport function mergeContentPacks(\n  basePack: any,\n  newPack: ContentPack,\n  mergeStrategy: 'merge' | 'replace' = 'merge'\n): ContentPackMergeResult {\n  const result: ContentPackMergeResult = {\n    success: true,\n    mergedData: { ...basePack },\n    appliedPacks: [],\n    conflicts: [],\n  };\n\n  if (!newPack.data) return result;\n\n  // 스토리 에피소드 머지\n  if (newPack.data.storyEpisodes) {\n    result.mergedData.storyEpisodes = mergeArrayData(\n      result.mergedData.storyEpisodes || [],\n      newPack.data.storyEpisodes,\n      'id',\n      mergeStrategy,\n      result.conflicts\n    );\n  }\n\n  // 캐릭터 머지\n  if (newPack.data.characters) {\n    result.mergedData.characters = mergeArrayData(\n      result.mergedData.characters || [],\n      newPack.data.characters,\n      'id',\n      mergeStrategy,\n      result.conflicts\n    );\n  }\n\n  // 이벤트 머지\n  if (newPack.data.events) {\n    result.mergedData.events = mergeArrayData(\n      result.mergedData.events || [],\n      newPack.data.events,\n      'id',\n      mergeStrategy,\n      result.conflicts\n    );\n  }\n\n  // 데코 머지\n  if (newPack.data.decor) {\n    result.mergedData.decor = mergeArrayData(\n      result.mergedData.decor || [],\n      newPack.data.decor,\n      'id',\n      mergeStrategy,\n      result.conflicts\n    );\n  }\n\n  // 오퍼 머지\n  if (newPack.data.offers) {\n    result.mergedData.offers = mergeArrayData(\n      result.mergedData.offers || [],\n      newPack.data.offers,\n      'id',\n      mergeStrategy,\n      result.conflicts\n    );\n  }\n\n  result.appliedPacks.push(newPack.id);\n  return result;\n}\n\n/**\n * 배열 데이터 머지 헬퍼\n */\nfunction mergeArrayData(\n  base: any[],\n  newData: any[],\n  keyField: string,\n  strategy: 'merge' | 'replace',\n  conflicts: Array<{ packId: string; itemId: string; reason: string }>\n): any[] {\n  const merged = [...base];\n  const baseIds = new Set(base.map((item) => item[keyField]));\n\n  for (const newItem of newData) {\n    const existingIndex = merged.findIndex((item) => item[keyField] === newItem[keyField]);\n\n    if (existingIndex >= 0) {\n      if (strategy === 'replace') {\n        merged[existingIndex] = newItem;\n      } else {\n        // merge 전략: 기존 데이터 유지, 충돌 기록\n        conflicts.push({\n          packId: newItem.id || 'unknown',\n          itemId: newItem[keyField],\n          reason: '기존 데이터 유지',\n        });\n      }\n    } else {\n      // 새 아이템 추가\n      merged.push(newItem);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * 콘텐츠 팩 캐시 저장\n */\nexport function cacheContentPacks(\n  packs: ContentPack[],\n  cacheStorage: Record<string, any>\n): Record<string, any> {\n  const cache = { ...cacheStorage };\n  cache.contentPacks = packs;\n  cache.lastUpdated = Date.now();\n  return cache;\n}\n\n/**\n * 캐시된 콘텐츠 팩 로드\n */\nexport function loadCachedContentPacks(\n  cacheStorage: Record<string, any>,\n  maxCacheAge: number = 86400000 // 24시간\n): { packs: ContentPack[]; isFresh: boolean } {\n  if (!cacheStorage.contentPacks) {\n    return { packs: [], isFresh: false };\n  }\n\n  const age = Date.now() - (cacheStorage.lastUpdated || 0);\n  const isFresh = age < maxCacheAge;\n\n  return { packs: cacheStorage.contentPacks, isFresh };\n}\n\n/**\n * 버전 비교\n * @returns -1 if v1 < v2, 0 if equal, 1 if v1 > v2\n */\nfunction compareVersions(v1: string, v2: string): number {\n  const parts1 = v1.split('.').map(Number);\n  const parts2 = v2.split('.').map(Number);\n\n  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {\n    const p1 = parts1[i] || 0;\n    const p2 = parts2[i] || 0;\n    if (p1 < p2) return -1;\n    if (p1 > p2) return 1;\n  }\n\n  return 0;\n}\n\n/**\n * 콘텐츠 팩 적용 상태 조회\n */\nexport function getContentPackStatus(\n  appliedPacks: string[],\n  availablePacks: ContentPack[]\n): {\n  applied: ContentPack[];\n  available: ContentPack[];\n  updateAvailable: boolean;\n} {\n  const applied = availablePacks.filter((p) => appliedPacks.includes(p.id));\n  const available = availablePacks.filter((p) => !appliedPacks.includes(p.id));\n\n  return {\n    applied,\n    available,\n    updateAvailable: available.length > 0,\n  };\n}\n
