/**\n * 로깅 유틸리티\n * 개발/프로덕션 환경에 따른 로그 레벨 조정\n */\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ninterface LogEntry {\n  timestamp: number;\n  level: LogLevel;\n  tag: string;\n  message: string;\n  data?: any;\n}\n\nclass Logger {\n  private static instance: Logger;\n  private logs: LogEntry[] = [];\n  private maxLogs = 1000;\n  private isDev = __DEV__;\n\n  private constructor() {}\n\n  static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  /**\n   * 디버그 로그\n   */\n  debug(tag: string, message: string, data?: any): void {\n    this._log('debug', tag, message, data);\n  }\n\n  /**\n   * 정보 로그\n   */\n  info(tag: string, message: string, data?: any): void {\n    this._log('info', tag, message, data);\n  }\n\n  /**\n   * 경고 로그\n   */\n  warn(tag: string, message: string, data?: any): void {\n    this._log('warn', tag, message, data);\n  }\n\n  /**\n   * 에러 로그\n   */\n  error(tag: string, message: string, data?: any): void {\n    this._log('error', tag, message, data);\n  }\n\n  /**\n   * 중요 이벤트 로깅\n   */\n  logEvent(\n    eventName: string,\n    data?: Record<string, any>\n  ): void {\n    this.info('EVENT', eventName, data);\n    // 추후 분석 서비스(Firebase Analytics 등)로 전송 가능\n  }\n\n  /**\n   * 내부 로깅\n   */\n  private _log(\n    level: LogLevel,\n    tag: string,\n    message: string,\n    data?: any\n  ): void {\n    const entry: LogEntry = {\n      timestamp: Date.now(),\n      level,\n      tag,\n      message,\n      data,\n    };\n\n    // 로그 저장\n    this.logs.push(entry);\n    if (this.logs.length > this.maxLogs) {\n      this.logs.shift();\n    }\n\n    // 콘솔 출력 (개발 환경)\n    if (this.isDev) {\n      const prefix = `[${tag}]`;\n      const logData = data ? ` ${JSON.stringify(data)}` : '';\n\n      switch (level) {\n        case 'debug':\n          console.debug(prefix, message, logData);\n          break;\n        case 'info':\n          console.log(prefix, message, logData);\n          break;\n        case 'warn':\n          console.warn(prefix, message, logData);\n          break;\n        case 'error':\n          console.error(prefix, message, logData);\n          break;\n      }\n    }\n  }\n\n  /**\n   * 로그 조회\n   */\n  getLogs(\n    filter?: {\n      tag?: string;\n      level?: LogLevel;\n      since?: number;\n    }\n  ): LogEntry[] {\n    let filtered = [...this.logs];\n\n    if (filter?.tag) {\n      filtered = filtered.filter((log) => log.tag === filter.tag);\n    }\n\n    if (filter?.level) {\n      filtered = filtered.filter((log) => log.level === filter.level);\n    }\n\n    if (filter?.since) {\n      filtered = filtered.filter((log) => log.timestamp >= filter.since!);\n    }\n\n    return filtered;\n  }\n\n  /**\n   * 로그 초기화\n   */\n  clearLogs(): void {\n    this.logs = [];\n  }\n\n  /**\n   * 로그 내보내기 (텍스트)\n   */\n  exportLogs(): string {\n    return this.logs\n      .map(\n        (log) =>\n          `[${new Date(log.timestamp).toISOString()}] [${log.level.toUpperCase()}] [${log.tag}] ${log.message}${log.data ? ` ${JSON.stringify(log.data)}` : ''}`\n      )\n      .join('\\n');\n  }\n}\n\nexport const logger = Logger.getInstance();\n\n/**\n * 편의 함수\n */\nexport function logDebug(tag: string, message: string, data?: any): void {\n  logger.debug(tag, message, data);\n}\n\nexport function logInfo(tag: string, message: string, data?: any): void {\n  logger.info(tag, message, data);\n}\n\nexport function logWarn(tag: string, message: string, data?: any): void {\n  logger.warn(tag, message, data);\n}\n\nexport function logError(tag: string, message: string, data?: any): void {\n  logger.error(tag, message, data);\n}\n\nexport function logEvent(eventName: string, data?: Record<string, any>): void {\n  logger.logEvent(eventName, data);\n}\n
