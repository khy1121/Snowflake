/**\n * 콘텐츠 팩 유닛 테스트\n */\n\nimport {\n  validateContentPack,\n  mergeContentPacks,\n  cacheContentPacks,\n  loadCachedContentPacks,\n  getContentPackStatus,\n} from '../services/ContentPackService';\n\nconst mockPack = {\n  id: 'pack_1',\n  version: '1.0.0',\n  checksum: 'abc123',\n  minAppVersion: '1.0.0',\n  data: {\n    storyEpisodes: [\n      { id: 'ep_1', name: 'Episode 1', content: 'Test' },\n    ],\n    characters: [\n      { id: 'char_1', name: 'Character 1' },\n    ],\n  },\n};\n\ndescribe('Content Pack Service', () => {\n  describe('Validation', () => {\n    test('validateContentPack should pass for valid pack', () => {\n      const result = validateContentPack(mockPack);\n      expect(result.valid).toBe(true);\n      expect(result.errors.length).toBe(0);\n    });\n\n    test('validateContentPack should fail for missing ID', () => {\n      const invalid = { ...mockPack, id: undefined };\n      const result = validateContentPack(invalid as any);\n      expect(result.valid).toBe(false);\n      expect(result.errors.length).toBeGreaterThan(0);\n    });\n\n    test('validateContentPack should fail for missing version', () => {\n      const invalid = { ...mockPack, version: undefined };\n      const result = validateContentPack(invalid as any);\n      expect(result.valid).toBe(false);\n    });\n\n    test('validateContentPack should fail for missing checksum', () => {\n      const invalid = { ...mockPack, checksum: undefined };\n      const result = validateContentPack(invalid as any);\n      expect(result.valid).toBe(false);\n    });\n\n    test('validateContentPack should fail for invalid data format', () => {\n      const invalid = {\n        ...mockPack,\n        data: { storyEpisodes: 'not_an_array' },\n      };\n      const result = validateContentPack(invalid as any);\n      expect(result.valid).toBe(false);\n    });\n  });\n\n  describe('Merge', () => {\n    test('mergeContentPacks should merge story episodes', () => {\n      const basePack = {\n        storyEpisodes: [\n          { id: 'ep_1', name: 'Episode 1' },\n        ],\n      };\n      const result = mergeContentPacks(basePack, mockPack, 'merge');\n      expect(result.success).toBe(true);\n      expect(result.mergedData.storyEpisodes.length).toBe(1);\n    });\n\n    test('mergeContentPacks should merge characters', () => {\n      const basePack = {\n        characters: [\n          { id: 'char_1', name: 'Character 1' },\n        ],\n      };\n      const result = mergeContentPacks(basePack, mockPack, 'merge');\n      expect(result.success).toBe(true);\n      expect(result.mergedData.characters.length).toBe(1);\n    });\n\n    test('mergeContentPacks should handle conflicts with merge strategy', () => {\n      const basePack = {\n        storyEpisodes: [\n          { id: 'ep_1', name: 'Episode 1 Original' },\n        ],\n      };\n      const newPack = {\n        ...mockPack,\n        data: {\n          storyEpisodes: [\n            { id: 'ep_1', name: 'Episode 1 New' },\n          ],\n        },\n      };\n      const result = mergeContentPacks(basePack, newPack, 'merge');\n      expect(result.success).toBe(true);\n      expect(result.conflicts.length).toBeGreaterThan(0);\n      expect(result.mergedData.storyEpisodes[0].name).toBe('Episode 1 Original');\n    });\n\n    test('mergeContentPacks should handle conflicts with replace strategy', () => {\n      const basePack = {\n        storyEpisodes: [\n          { id: 'ep_1', name: 'Episode 1 Original' },\n        ],\n      };\n      const newPack = {\n        ...mockPack,\n        data: {\n          storyEpisodes: [\n            { id: 'ep_1', name: 'Episode 1 New' },\n          ],\n        },\n      };\n      const result = mergeContentPacks(basePack, newPack, 'replace');\n      expect(result.success).toBe(true);\n      expect(result.mergedData.storyEpisodes[0].name).toBe('Episode 1 New');\n    });\n\n    test('mergeContentPacks should add new items', () => {\n      const basePack = {\n        storyEpisodes: [\n          { id: 'ep_1', name: 'Episode 1' },\n        ],\n      };\n      const newPack = {\n        ...mockPack,\n        data: {\n          storyEpisodes: [\n            { id: 'ep_2', name: 'Episode 2' },\n          ],\n        },\n      };\n      const result = mergeContentPacks(basePack, newPack, 'merge');\n      expect(result.success).toBe(true);\n      expect(result.mergedData.storyEpisodes.length).toBe(2);\n    });\n  });\n\n  describe('Cache', () => {\n    test('cacheContentPacks should save packs', () => {\n      const cache = {};\n      const result = cacheContentPacks([mockPack], cache);\n      expect(result.contentPacks).toBeDefined();\n      expect(result.contentPacks.length).toBe(1);\n      expect(result.lastUpdated).toBeGreaterThan(0);\n    });\n\n    test('loadCachedContentPacks should load packs', () => {\n      const cache = { contentPacks: [mockPack], lastUpdated: Date.now() };\n      const result = loadCachedContentPacks(cache);\n      expect(result.packs.length).toBe(1);\n      expect(result.isFresh).toBe(true);\n    });\n\n    test('loadCachedContentPacks should return empty for no cache', () => {\n      const cache = {};\n      const result = loadCachedContentPacks(cache);\n      expect(result.packs.length).toBe(0);\n      expect(result.isFresh).toBe(false);\n    });\n\n    test('loadCachedContentPacks should check cache age', () => {\n      const cache = {\n        contentPacks: [mockPack],\n        lastUpdated: Date.now() - 100000000, // 27+ hours ago\n      };\n      const result = loadCachedContentPacks(cache, 86400000); // 24 hour max\n      expect(result.isFresh).toBe(false);\n    });\n  });\n\n  describe('Status', () => {\n    test('getContentPackStatus should show applied packs', () => {\n      const status = getContentPackStatus(['pack_1'], [mockPack]);\n      expect(status.applied.length).toBe(1);\n      expect(status.available.length).toBe(0);\n      expect(status.updateAvailable).toBe(false);\n    });\n\n    test('getContentPackStatus should show available packs', () => {\n      const status = getContentPackStatus([], [mockPack]);\n      expect(status.applied.length).toBe(0);\n      expect(status.available.length).toBe(1);\n      expect(status.updateAvailable).toBe(true);\n    });\n\n    test('getContentPackStatus should handle mixed state', () => {\n      const pack2 = { ...mockPack, id: 'pack_2' };\n      const status = getContentPackStatus(['pack_1'], [mockPack, pack2]);\n      expect(status.applied.length).toBe(1);\n      expect(status.available.length).toBe(1);\n      expect(status.updateAvailable).toBe(true);\n    });\n  });\n});\n
