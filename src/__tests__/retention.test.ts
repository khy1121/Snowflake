/**\n * 복귀/막힘 감지 유닛 테스트\n */\n\nimport {\n  isComebackUser,\n  canClaimComebackPack,\n  calculateComebackReward,\n  recordBattle,\n  calculateAverageTTK,\n  detectStuck,\n  recordStuckDetection,\n  getStuckDetectionFrequency,\n  shouldUnlockMode,\n  updateRetentionState,\n} from '../features/retention/retentionEngine';\n\ndescribe('Retention Engine', () => {\n  describe('Comeback User Detection', () => {\n    test('isComebackUser should return true for inactive user', () => {\n      const lastActiveAt = Date.now() - 86400000 * 2; // 2 days ago\n      expect(isComebackUser(lastActiveAt, 86400000)).toBe(true);\n    });\n\n    test('isComebackUser should return false for active user', () => {\n      const lastActiveAt = Date.now() - 3600000; // 1 hour ago\n      expect(isComebackUser(lastActiveAt, 86400000)).toBe(false);\n    });\n\n    test('isComebackUser should return false at threshold', () => {\n      const lastActiveAt = Date.now() - 86400000; // exactly 24 hours ago\n      expect(isComebackUser(lastActiveAt, 86400000)).toBe(true);\n    });\n  });\n\n  describe('Comeback Pack', () => {\n    test('canClaimComebackPack should return true for eligible user', () => {\n      const lastActiveAt = Date.now() - 86400000 * 2;\n      expect(\n        canClaimComebackPack(lastActiveAt, undefined, 86400000)\n      ).toBe(true);\n    });\n\n    test('canClaimComebackPack should return false if already claimed recently', () => {\n      const lastActiveAt = Date.now() - 86400000 * 2;\n      const comebackPackClaimedAt = Date.now() - 3600000; // 1 hour ago\n      expect(\n        canClaimComebackPack(lastActiveAt, comebackPackClaimedAt, 86400000)\n      ).toBe(false);\n    });\n\n    test('calculateComebackReward should scale with stage', () => {\n      const reward10 = calculateComebackReward(10);\n      const reward20 = calculateComebackReward(20);\n      expect(reward20.fragments).toBeGreaterThanOrEqual(reward10.fragments);\n    });\n\n    test('calculateComebackReward should return fixed values', () => {\n      const reward = calculateComebackReward(10, 50, 5000, 100);\n      expect(reward.fragments).toBe(50);\n      expect(reward.gold).toBe(5000);\n      expect(reward.cosmeticToken).toBe(100);\n    });\n  });\n\n  describe('Battle History', () => {\n    test('recordBattle should add new record', () => {\n      let history: any[] = [];\n      history = recordBattle(history, 10, 15000);\n      expect(history.length).toBe(1);\n      expect(history[0].stage).toBe(10);\n      expect(history[0].timeToKill).toBe(15000);\n    });\n\n    test('recordBattle should maintain max records', () => {\n      let history: any[] = [];\n      for (let i = 0; i < 15; i++) {\n        history = recordBattle(history, 10 + i, 15000 + i * 1000, 10);\n      }\n      expect(history.length).toBe(10);\n    });\n\n    test('calculateAverageTTK should calculate correctly', () => {\n      const history = [\n        { stage: 10, timeToKill: 10000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 20000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 30000, timestamp: Date.now() },\n      ];\n      const avg = calculateAverageTTK(history);\n      expect(avg).toBe(20000);\n    });\n\n    test('calculateAverageTTK should return 0 for empty history', () => {\n      const avg = calculateAverageTTK([]);\n      expect(avg).toBe(0);\n    });\n  });\n\n  describe('Stuck Detection', () => {\n    test('detectStuck should return false for fast battles', () => {\n      const history = [\n        { stage: 10, timeToKill: 10000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 12000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 11000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 13000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 12000, timestamp: Date.now() },\n      ];\n      const result = detectStuck(history, 25000);\n      expect(result.isStuck).toBe(false);\n    });\n\n    test('detectStuck should return true for slow battles', () => {\n      const history = [\n        { stage: 10, timeToKill: 30000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 28000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 32000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 29000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 31000, timestamp: Date.now() },\n      ];\n      const result = detectStuck(history, 25000);\n      expect(result.isStuck).toBe(true);\n    });\n\n    test('detectStuck should recommend upgrade for early stages', () => {\n      const history = [\n        { stage: 20, timeToKill: 30000, timestamp: Date.now() },\n        { stage: 20, timeToKill: 28000, timestamp: Date.now() },\n        { stage: 20, timeToKill: 32000, timestamp: Date.now() },\n        { stage: 20, timeToKill: 29000, timestamp: Date.now() },\n        { stage: 20, timeToKill: 31000, timestamp: Date.now() },\n      ];\n      const result = detectStuck(history, 25000);\n      expect(result.recommendationType).toBe('upgrade');\n    });\n\n    test('detectStuck should recommend mode for mid stages', () => {\n      const history = [\n        { stage: 60, timeToKill: 30000, timestamp: Date.now() },\n        { stage: 60, timeToKill: 28000, timestamp: Date.now() },\n        { stage: 60, timeToKill: 32000, timestamp: Date.now() },\n        { stage: 60, timeToKill: 29000, timestamp: Date.now() },\n        { stage: 60, timeToKill: 31000, timestamp: Date.now() },\n      ];\n      const result = detectStuck(history, 25000);\n      expect(result.recommendationType).toBe('mode');\n    });\n\n    test('detectStuck should recommend prestige for late stages', () => {\n      const history = [\n        { stage: 110, timeToKill: 30000, timestamp: Date.now() },\n        { stage: 110, timeToKill: 28000, timestamp: Date.now() },\n        { stage: 110, timeToKill: 32000, timestamp: Date.now() },\n        { stage: 110, timeToKill: 29000, timestamp: Date.now() },\n        { stage: 110, timeToKill: 31000, timestamp: Date.now() },\n      ];\n      const result = detectStuck(history, 25000);\n      expect(result.recommendationType).toBe('prestige');\n    });\n\n    test('detectStuck should return false for insufficient records', () => {\n      const history = [\n        { stage: 10, timeToKill: 30000, timestamp: Date.now() },\n        { stage: 10, timeToKill: 28000, timestamp: Date.now() },\n      ];\n      const result = detectStuck(history, 25000, 5);\n      expect(result.isStuck).toBe(false);\n    });\n  });\n\n  describe('Stuck Detection History', () => {\n    test('recordStuckDetection should add record', () => {\n      let history: any[] = [];\n      history = recordStuckDetection(history, 30000, 'upgrade');\n      expect(history.length).toBe(1);\n      expect(history[0].recommendationType).toBe('upgrade');\n    });\n\n    test('getStuckDetectionFrequency should count recent detections', () => {\n      const now = Date.now();\n      const history = [\n        { detectedAt: now - 600000, averageTTK: 30000, recommendationType: 'upgrade' as const },\n        { detectedAt: now - 300000, averageTTK: 30000, recommendationType: 'upgrade' as const },\n        { detectedAt: now - 100000, averageTTK: 30000, recommendationType: 'upgrade' as const },\n      ];\n      const frequency = getStuckDetectionFrequency(history, 3600000);\n      expect(frequency).toBe(3);\n    });\n  });\n\n  describe('Mode Unlock', () => {\n    test('shouldUnlockMode should return true when stage reached', () => {\n      expect(shouldUnlockMode(15, 10)).toBe(true);\n    });\n\n    test('shouldUnlockMode should return false when stage not reached', () => {\n      expect(shouldUnlockMode(5, 10)).toBe(false);\n    });\n\n    test('shouldUnlockMode should return true at exact stage', () => {\n      expect(shouldUnlockMode(10, 10)).toBe(true);\n    });\n  });\n\n  describe('Retention State', () => {\n    test('updateRetentionState should update lastActiveAt', () => {\n      const state = {\n        lastActiveAt: Date.now() - 3600000,\n        battleHistory: [],\n        stuckDetectionHistory: [],\n      };\n      const updated = updateRetentionState(state, {});\n      expect(updated.lastActiveAt).toBeGreaterThan(state.lastActiveAt);\n    });\n  });\n});\n
