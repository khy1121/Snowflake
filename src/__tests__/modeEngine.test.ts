/**\n * 모드 엔진 유닛 테스트\n */\n\nimport {\n  getEntriesUsedToday,\n  canEnterMode,\n  recordModeEntry,\n  calculateTimeAttackScore,\n  initializeTimeAttackSession,\n  updateTimeAttackSession,\n  finishTimeAttackSession,\n  initializeChoiceSession,\n  selectChoice,\n  finishChoiceSession,\n  getTimeRemaining,\n  getProgress,\n} from '../features/modes/modeEngine';\n\ndescribe('Mode Engine', () => {\n  describe('Entry Management', () => {\n    test('getEntriesUsedToday should return 0 for new mode', () => {\n      const entries = [];\n      const used = getEntriesUsedToday(entries, 'night_maintenance', '2024-01-06');\n      expect(used).toBe(0);\n    });\n\n    test('canEnterMode should return true when entries available', () => {\n      const entries = [];\n      const can = canEnterMode(entries, 'night_maintenance', 3, '2024-01-06');\n      expect(can).toBe(true);\n    });\n\n    test('canEnterMode should return false when entries exhausted', () => {\n      const entries = [\n        { modeId: 'night_maintenance', date: '2024-01-06', entriesUsed: 3 },\n      ];\n      const can = canEnterMode(entries, 'night_maintenance', 3, '2024-01-06');\n      expect(can).toBe(false);\n    });\n\n    test('recordModeEntry should increment entries', () => {\n      let entries: any[] = [];\n      entries = recordModeEntry(entries, 'night_maintenance', '2024-01-06');\n      entries = recordModeEntry(entries, 'night_maintenance', '2024-01-06');\n      const used = getEntriesUsedToday(entries, 'night_maintenance', '2024-01-06');\n      expect(used).toBe(2);\n    });\n\n    test('recordModeEntry should create new entry for different date', () => {\n      let entries: any[] = [];\n      entries = recordModeEntry(entries, 'night_maintenance', '2024-01-06');\n      entries = recordModeEntry(entries, 'night_maintenance', '2024-01-07');\n      expect(entries.length).toBe(2);\n    });\n  });\n\n  describe('Time Attack Score', () => {\n    test('calculateTimeAttackScore should calculate correctly', () => {\n      const score = calculateTimeAttackScore(\n        10, // kills\n        2, // bossKills\n        25, // currentStage\n        10, // basePerKill\n        5, // bossMultiplier\n        1 // stageBonus\n      );\n      // kills: 10*10 = 100\n      // bossKills: 2*10*5 = 100\n      // stage: 25*1 = 25\n      // total: 225\n      expect(score).toBe(225);\n    });\n\n    test('calculateTimeAttackScore should handle zero values', () => {\n      const score = calculateTimeAttackScore(0, 0, 0);\n      expect(score).toBe(0);\n    });\n  });\n\n  describe('Time Attack Session', () => {\n    test('initializeTimeAttackSession should create session', () => {\n      const session = initializeTimeAttackSession('night_maintenance', 60000, 25);\n      expect(session.modeId).toBe('night_maintenance');\n      expect(session.duration).toBe(60000);\n      expect(session.currentStage).toBe(25);\n      expect(session.kills).toBe(0);\n      expect(session.isActive).toBe(true);\n    });\n\n    test('updateTimeAttackSession should update kills and score', () => {\n      const session = initializeTimeAttackSession('night_maintenance', 60000, 25);\n      const updated = updateTimeAttackSession(session, 5, 1);\n      expect(updated.kills).toBe(5);\n      expect(updated.bossKills).toBe(1);\n      expect(updated.score).toBeGreaterThan(0);\n    });\n\n    test('finishTimeAttackSession should set isActive to false', () => {\n      const session = initializeTimeAttackSession('night_maintenance', 60000, 25);\n      const finished = finishTimeAttackSession(session);\n      expect(finished.isActive).toBe(false);\n    });\n\n    test('getTimeRemaining should return positive value', () => {\n      const session = initializeTimeAttackSession('night_maintenance', 60000, 25);\n      const remaining = getTimeRemaining(session);\n      expect(remaining).toBeGreaterThan(0);\n      expect(remaining).toBeLessThanOrEqual(60000);\n    });\n  });\n\n  describe('Choice Session', () => {\n    test('initializeChoiceSession should create session', () => {\n      const session = initializeChoiceSession('infiltration', 3);\n      expect(session.modeId).toBe('infiltration');\n      expect(session.totalRounds).toBe(3);\n      expect(session.currentRound).toBe(1);\n      expect(session.selectedBuffs.length).toBe(0);\n      expect(session.isActive).toBe(true);\n    });\n\n    test('selectChoice should add buff and advance round', () => {\n      let session = initializeChoiceSession('infiltration', 3);\n      session = selectChoice(session, 'atk_boost');\n      expect(session.selectedBuffs).toContain('atk_boost');\n      expect(session.currentRound).toBe(2);\n      expect(session.isActive).toBe(true);\n    });\n\n    test('selectChoice should complete session after all rounds', () => {\n      let session = initializeChoiceSession('infiltration', 3);\n      session = selectChoice(session, 'atk_boost');\n      session = selectChoice(session, 'offline_boost');\n      session = selectChoice(session, 'crit_boost');\n      expect(session.selectedBuffs.length).toBe(3);\n      expect(session.isActive).toBe(false);\n    });\n\n    test('getProgress should calculate correctly', () => {\n      let session = initializeChoiceSession('infiltration', 3);\n      expect(getProgress(session)).toBe(1 / 3);\n      session = selectChoice(session, 'atk_boost');\n      expect(getProgress(session)).toBe(2 / 3);\n      session = selectChoice(session, 'offline_boost');\n      expect(getProgress(session)).toBe(1);\n    });\n\n    test('finishChoiceSession should set isActive to false', () => {\n      const session = initializeChoiceSession('infiltration', 3);\n      const finished = finishChoiceSession(session);\n      expect(finished.isActive).toBe(false);\n    });\n  });\n});\n
