/**\n * 오퍼 유닛 테스트\n */\n\nimport {\n  isOfferEligible,\n  getEligibleOffers,\n  getRecommendedOffers,\n  purchaseOffer,\n  recordOfferPurchase,\n  recordOfferShown,\n  formatOfferPrice,\n  getOfferContentsDescription,\n  validateOfferData,\n} from '../features/shop/offerEngine';\n\nconst mockOffers = [\n  {\n    id: 'starter_pack',\n    name: '시작 팩',\n    description: '새로운 기술자를 위한 특별 팩',\n    type: 'starter',\n    price: 4900,\n    priceCurrency: 'KRW',\n    priceUSD: 3.99,\n    contents: [\n      { type: 'gold', amount: 5000 },\n      { type: 'cosmeticToken', amount: 500 },\n    ],\n    eligibility: {\n      minStage: 0,\n      maxStage: 5,\n      minDaysActive: 0,\n      maxDaysActive: 1,\n      maxPurchases: 1,\n    },\n    displayPriority: 1,\n    expiresIn: 86400000,\n  },\n  {\n    id: 'comeback_pack',\n    name: '복귀 팩',\n    description: '오랜만에 돌아온 기술자를 위한 팩',\n    type: 'comeback',\n    price: 2900,\n    priceCurrency: 'KRW',\n    priceUSD: 2.99,\n    contents: [{ type: 'gold', amount: 3000 }],\n    eligibility: {\n      minInactiveDays: 3,\n      maxPurchases: 1,\n      cooldownDays: 7,\n    },\n    displayPriority: 2,\n    expiresIn: 172800000,\n  },\n];\n\ndescribe('Offer Engine', () => {\n  describe('Eligibility', () => {\n    test('isOfferEligible should return true for eligible offer', () => {\n      const result = isOfferEligible(mockOffers[0], 3, 0.5, 0, {}, 0);\n      expect(result).toBe(true);\n    });\n\n    test('isOfferEligible should return false for stage too high', () => {\n      const result = isOfferEligible(mockOffers[0], 10, 0.5, 0, {}, 0);\n      expect(result).toBe(false);\n    });\n\n    test('isOfferEligible should return false for days active too high', () => {\n      const result = isOfferEligible(mockOffers[0], 3, 2, 0, {}, 0);\n      expect(result).toBe(false);\n    });\n\n    test('isOfferEligible should check max purchases', () => {\n      const result = isOfferEligible(mockOffers[0], 3, 0.5, 0, { starter_pack: 1 }, 0);\n      expect(result).toBe(false);\n    });\n\n    test('isOfferEligible should check inactive days', () => {\n      const result = isOfferEligible(mockOffers[1], 0, 0, 5, {}, 0);\n      expect(result).toBe(true);\n      const result2 = isOfferEligible(mockOffers[1], 0, 0, 2, {}, 0);\n      expect(result2).toBe(false);\n    });\n\n    test('isOfferEligible should check cooldown', () => {\n      const now = Date.now();\n      const lastShownAt = { comeback_pack: now - 3600000 }; // 1시간 전\n      const result = isOfferEligible(mockOffers[1], 0, 0, 5, {}, 0, lastShownAt);\n      expect(result).toBe(false); // 쿨다운 미충족\n    });\n  });\n\n  describe('Get Eligible Offers', () => {\n    test('getEligibleOffers should return matching offers', () => {\n      const eligible = getEligibleOffers(mockOffers, 3, 0.5, 0, {}, 0);\n      expect(eligible.length).toBeGreaterThan(0);\n      expect(eligible.some((o) => o.id === 'starter_pack')).toBe(true);\n    });\n\n    test('getEligibleOffers should filter by stage', () => {\n      const eligible = getEligibleOffers(mockOffers, 10, 0.5, 0, {}, 0);\n      expect(eligible.some((o) => o.id === 'starter_pack')).toBe(false);\n    });\n  });\n\n  describe('Get Recommended Offers', () => {\n    test('getRecommendedOffers should return sorted by priority', () => {\n      const recommended = getRecommendedOffers(mockOffers, 3, 0.5, 0, {}, 0, {}, 5);\n      if (recommended.length > 1) {\n        expect(recommended[0].displayPriority).toBeLessThanOrEqual(\n          recommended[1].displayPriority\n        );\n      }\n    });\n\n    test('getRecommendedOffers should respect max recommendations', () => {\n      const recommended = getRecommendedOffers(mockOffers, 3, 0.5, 0, {}, 0, {}, 1);\n      expect(recommended.length).toBeLessThanOrEqual(1);\n    });\n  });\n\n  describe('Purchase', () => {\n    test('purchaseOffer should succeed with sufficient tokens', () => {\n      const result = purchaseOffer(mockOffers[0], 5000);\n      expect(result.success).toBe(true);\n      expect(result.remainingTokens).toBe(100);\n    });\n\n    test('purchaseOffer should fail with insufficient tokens', () => {\n      const result = purchaseOffer(mockOffers[0], 1000);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('토큰 부족');\n    });\n\n    test('purchaseOffer should return contents', () => {\n      const result = purchaseOffer(mockOffers[0], 5000);\n      expect(result.contents).toBeDefined();\n      expect(result.contents?.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Purchase History', () => {\n    test('recordOfferPurchase should update purchase count', () => {\n      const history = {};\n      const updated = recordOfferPurchase(history, 'starter_pack');\n      expect(updated.starter_pack).toBe(1);\n    });\n\n    test('recordOfferPurchase should increment count', () => {\n      const history = { starter_pack: 1 };\n      const updated = recordOfferPurchase(history, 'starter_pack');\n      expect(updated.starter_pack).toBe(2);\n    });\n  });\n\n  describe('Shown History', () => {\n    test('recordOfferShown should record timestamp', () => {\n      const lastShownAt = {};\n      const updated = recordOfferShown(lastShownAt, 'starter_pack');\n      expect(updated.starter_pack).toBeGreaterThan(0);\n    });\n\n    test('recordOfferShown should preserve creation timestamp', () => {\n      const lastShownAt = { starter_pack_created: 1000 };\n      const updated = recordOfferShown(lastShownAt, 'starter_pack');\n      expect(updated.starter_pack_created).toBe(1000);\n    });\n  });\n\n  describe('Price Formatting', () => {\n    test('formatOfferPrice should format KRW', () => {\n      const formatted = formatOfferPrice(mockOffers[0], 'KRW');\n      expect(formatted).toContain('₩');\n      expect(formatted).toContain('4,900');\n    });\n\n    test('formatOfferPrice should format USD', () => {\n      const formatted = formatOfferPrice(mockOffers[0], 'USD');\n      expect(formatted).toContain('$');\n      expect(formatted).toContain('3.99');\n    });\n  });\n\n  describe('Contents Description', () => {\n    test('getOfferContentsDescription should describe contents', () => {\n      const descriptions = getOfferContentsDescription(mockOffers[0].contents);\n      expect(descriptions.length).toBe(2);\n      expect(descriptions[0]).toContain('골드');\n      expect(descriptions[1]).toContain('토큰');\n    });\n  });\n\n  describe('Validation', () => {\n    test('validateOfferData should pass for valid data', () => {\n      const result = validateOfferData(mockOffers);\n      expect(result.valid).toBe(true);\n      expect(result.errors.length).toBe(0);\n    });\n\n    test('validateOfferData should fail for missing ID', () => {\n      const invalid = [{ name: 'Test', price: 100, contents: [] }];\n      const result = validateOfferData(invalid as any);\n      expect(result.valid).toBe(false);\n    });\n  });\n});\n
