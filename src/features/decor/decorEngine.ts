/**\n * 정비소 데코(꾸미기) 시스템 엔진\n * Sprint 11: 데코 구매, 배치, 프리셋 저장/로드\n */\n\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface DecorItem {\n  id: string;\n  name: string;\n  description: string;\n  type: 'WALL' | 'FLOOR' | 'OBJECT' | 'LIGHT' | 'SIGN' | 'MASCOT';\n  priceTokens: number;\n  unlockCondition: any;\n  tags: string[];\n  rarityLabel: string;\n  placement: {\n    width: number;\n    height: number;\n    anchor: string;\n    zIndex: number;\n    gridSnap: number;\n  };\n  render: {\n    styleKey: string;\n    colors: string[];\n    emojiOrIconKey: string;\n  };\n}\n\nexport interface DecorPlacement {\n  itemId: string;\n  x: number;\n  y: number;\n  zIndex: number;\n  rotation?: number;\n}\n\nexport interface DecorPreset {\n  id: string;\n  name: string;\n  placements: DecorPlacement[];\n  wall?: string; // wallItemId\n  floor?: string; // floorItemId\n  createdAt: number;\n}\n\nexport interface DecorInventory {\n  ownedItemIds: string[]; // 보유한 데코 ID 목록\n  placements: DecorPlacement[]; // 현재 배치\n  selectedWall?: string;\n  selectedFloor?: string;\n  presets: DecorPreset[]; // 최대 3개\n  lastModified: number;\n}\n\n/**\n * 기본 인벤토리 생성\n */\nexport function createDefaultInventory(): DecorInventory {\n  return {\n    ownedItemIds: ['wall_wood_basic', 'floor_wood_basic'], // 기본 데코\n    placements: [],\n    selectedWall: 'wall_wood_basic',\n    selectedFloor: 'floor_wood_basic',\n    presets: [],\n    lastModified: Date.now(),\n  };\n}\n\n/**\n * 데코 구매\n */\nexport function purchaseDecor(\n  inventory: DecorInventory,\n  itemId: string,\n  currentTokens: number,\n  itemPrice: number\n): { success: boolean; newInventory?: DecorInventory; error?: string; remainingTokens?: number } {\n  // 이미 보유 중인지 확인\n  if (inventory.ownedItemIds.includes(itemId)) {\n    return { success: false, error: '이미 보유 중인 데코입니다.' };\n  }\n\n  // 토큰 확인\n  if (currentTokens < itemPrice) {\n    return { success: false, error: '토큰이 부족합니다.' };\n  }\n\n  const newInventory = {\n    ...inventory,\n    ownedItemIds: [...inventory.ownedItemIds, itemId],\n    lastModified: Date.now(),\n  };\n\n  return {\n    success: true,\n    newInventory,\n    remainingTokens: currentTokens - itemPrice,\n  };\n}\n\n/**\n * 데코 배치 추가\n */\nexport function addPlacement(\n  inventory: DecorInventory,\n  itemId: string,\n  x: number,\n  y: number\n): { success: boolean; newInventory?: DecorInventory; error?: string } {\n  // 보유 확인\n  if (!inventory.ownedItemIds.includes(itemId)) {\n    return { success: false, error: '보유하지 않은 데코입니다.' };\n  }\n\n  const newPlacement: DecorPlacement = {\n    itemId,\n    x,\n    y,\n    zIndex: 1,\n  };\n\n  const newInventory = {\n    ...inventory,\n    placements: [...inventory.placements, newPlacement],\n    lastModified: Date.now(),\n  };\n\n  return { success: true, newInventory };\n}\n\n/**\n * 데코 배치 수정\n */\nexport function updatePlacement(\n  inventory: DecorInventory,\n  placementIndex: number,\n  updates: Partial<DecorPlacement>\n): { success: boolean; newInventory?: DecorInventory; error?: string } {\n  if (placementIndex < 0 || placementIndex >= inventory.placements.length) {\n    return { success: false, error: '유효하지 않은 배치 인덱스입니다.' };\n  }\n\n  const newPlacements = inventory.placements.map((p, i) =>\n    i === placementIndex ? { ...p, ...updates } : p\n  );\n\n  const newInventory = {\n    ...inventory,\n    placements: newPlacements,\n    lastModified: Date.now(),\n  };\n\n  return { success: true, newInventory };\n}\n\n/**\n * 데코 배치 삭제\n */\nexport function removePlacement(\n  inventory: DecorInventory,\n  placementIndex: number\n): { success: boolean; newInventory?: DecorInventory; error?: string } {\n  if (placementIndex < 0 || placementIndex >= inventory.placements.length) {\n    return { success: false, error: '유효하지 않은 배치 인덱스입니다.' };\n  }\n\n  const newPlacements = inventory.placements.filter((_, i) => i !== placementIndex);\n\n  const newInventory = {\n    ...inventory,\n    placements: newPlacements,\n    lastModified: Date.now(),\n  };\n\n  return { success: true, newInventory };\n}\n\n/**\n * 벽 선택\n */\nexport function selectWall(\n  inventory: DecorInventory,\n  wallItemId: string\n): { success: boolean; newInventory?: DecorInventory; error?: string } {\n  if (!inventory.ownedItemIds.includes(wallItemId)) {\n    return { success: false, error: '보유하지 않은 벽입니다.' };\n  }\n\n  const newInventory = {\n    ...inventory,\n    selectedWall: wallItemId,\n    lastModified: Date.now(),\n  };\n\n  return { success: true, newInventory };\n}\n\n/**\n * 바닥 선택\n */\nexport function selectFloor(\n  inventory: DecorInventory,\n  floorItemId: string\n): { success: boolean; newInventory?: DecorInventory; error?: string } {\n  if (!inventory.ownedItemIds.includes(floorItemId)) {\n    return { success: false, error: '보유하지 않은 바닥입니다.' };\n  }\n\n  const newInventory = {\n    ...inventory,\n    selectedFloor: floorItemId,\n    lastModified: Date.now(),\n  };\n\n  return { success: true, newInventory };\n}\n\n/**\n * 프리셋 저장\n */\nexport function savePreset(\n  inventory: DecorInventory,\n  presetName: string\n): { success: boolean; newInventory?: DecorInventory; error?: string } {\n  if (inventory.presets.length >= 3) {\n    return { success: false, error: '프리셋은 최대 3개까지만 저장할 수 있습니다.' };\n  }\n\n  const newPreset: DecorPreset = {\n    id: uuidv4(),\n    name: presetName.substring(0, 20), // 최대 20자\n    placements: [...inventory.placements],\n    wall: inventory.selectedWall,\n    floor: inventory.selectedFloor,\n    createdAt: Date.now(),\n  };\n\n  const newInventory = {\n    ...inventory,\n    presets: [...inventory.presets, newPreset],\n    lastModified: Date.now(),\n  };\n\n  return { success: true, newInventory };\n}\n\n/**\n * 프리셋 로드\n */\nexport function loadPreset(\n  inventory: DecorInventory,\n  presetId: string\n): { success: boolean; newInventory?: DecorInventory; error?: string } {\n  const preset = inventory.presets.find(p => p.id === presetId);\n  if (!preset) {\n    return { success: false, error: '프리셋을 찾을 수 없습니다.' };\n  }\n\n  const newInventory = {\n    ...inventory,\n    placements: [...preset.placements],\n    selectedWall: preset.wall,\n    selectedFloor: preset.floor,\n    lastModified: Date.now(),\n  };\n\n  return { success: true, newInventory };\n}\n\n/**\n * 프리셋 삭제\n */\nexport function deletePreset(\n  inventory: DecorInventory,\n  presetId: string\n): { success: boolean; newInventory?: DecorInventory; error?: string } {\n  const presetIndex = inventory.presets.findIndex(p => p.id === presetId);\n  if (presetIndex === -1) {\n    return { success: false, error: '프리셋을 찾을 수 없습니다.' };\n  }\n\n  const newInventory = {\n    ...inventory,\n    presets: inventory.presets.filter((_, i) => i !== presetIndex),\n    lastModified: Date.now(),\n  };\n\n  return { success: true, newInventory };\n}\n\n/**\n * 프리셋 이름 변경\n */\nexport function renamePreset(\n  inventory: DecorInventory,\n  presetId: string,\n  newName: string\n): { success: boolean; newInventory?: DecorInventory; error?: string } {\n  const presetIndex = inventory.presets.findIndex(p => p.id === presetId);\n  if (presetIndex === -1) {\n    return { success: false, error: '프리셋을 찾을 수 없습니다.' };\n  }\n\n  const newPresets = inventory.presets.map((p, i) =>\n    i === presetIndex ? { ...p, name: newName.substring(0, 20) } : p\n  );\n\n  const newInventory = {\n    ...inventory,\n    presets: newPresets,\n    lastModified: Date.now(),\n  };\n\n  return { success: true, newInventory };\n}\n\n/**\n * 배치 초기화\n */\nexport function clearAllPlacements(\n  inventory: DecorInventory\n): { success: boolean; newInventory?: DecorInventory } {\n  const newInventory = {\n    ...inventory,\n    placements: [],\n    lastModified: Date.now(),\n  };\n\n  return { success: true, newInventory };\n}\n
