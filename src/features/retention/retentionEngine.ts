/**\n * 복귀/막힘 감지 엔진\n * 복귀 유저 팩, 막힘 감지\n */\n\nexport interface RetentionState {\n  lastActiveAt: number;\n  comebackPackClaimedAt?: number;\n  battleHistory: BattleRecord[];\n  stuckDetectionHistory: StuckDetectionRecord[];\n}\n\nexport interface BattleRecord {\n  stage: number;\n  timeToKill: number; // ms\n  timestamp: number;\n}\n\nexport interface StuckDetectionRecord {\n  detectedAt: number;\n  averageTTK: number;\n  recommendationType: 'upgrade' | 'prestige' | 'mode';\n}\n\nexport interface ComebackPackReward {\n  fragments: number;\n  gold: number;\n  cosmeticToken: number;\n}\n\n/**\n * 복귀 유저 판정\n */\nexport function isComebackUser(\n  lastActiveAt: number,\n  minInactivityMs: number = 86400000 // 24시간\n): boolean {\n  const now = Date.now();\n  const inactivityTime = now - lastActiveAt;\n  return inactivityTime >= minInactivityMs;\n}\n\n/**\n * 복귀 팩 수령 가능 여부\n */\nexport function canClaimComebackPack(\n  lastActiveAt: number,\n  comebackPackClaimedAt: number | undefined,\n  minInactivityMs: number = 86400000\n): boolean {\n  if (!isComebackUser(lastActiveAt, minInactivityMs)) {\n    return false;\n  }\n\n  if (comebackPackClaimedAt === undefined) {\n    return true;\n  }\n\n  // 한 번만 수령 가능 (또는 주기적으로 설정 가능)\n  const timeSinceClaim = Date.now() - comebackPackClaimedAt;\n  const minClaimIntervalMs = 604800000; // 7일\n  return timeSinceClaim >= minClaimIntervalMs;\n}\n\n/**\n * 복귀 팩 보상 계산\n */\nexport function calculateComebackReward(\n  stage: number,\n  baseFragments: number = 50,\n  baseGold: number = 5000,\n  baseCosmeticToken: number = 100\n): ComebackPackReward {\n  const stageMultiplier = Math.max(1, Math.floor(stage / 10));\n  return {\n    fragments: baseFragments * stageMultiplier,\n    gold: baseGold * stageMultiplier,\n    cosmeticToken: baseCosmeticToken,\n  };\n}\n\n/**\n * 전투 기록 추가\n */\nexport function recordBattle(\n  history: BattleRecord[],\n  stage: number,\n  timeToKill: number,\n  maxRecords: number = 10\n): BattleRecord[] {\n  const newRecord: BattleRecord = {\n    stage,\n    timeToKill,\n    timestamp: Date.now(),\n  };\n\n  const updated = [newRecord, ...history].slice(0, maxRecords);\n  return updated;\n}\n\n/**\n * 평균 TTK 계산\n */\nexport function calculateAverageTTK(history: BattleRecord[]): number {\n  if (history.length === 0) return 0;\n  const totalTTK = history.reduce((sum, record) => sum + record.timeToKill, 0);\n  return totalTTK / history.length;\n}\n\n/**\n * 막힘 감지\n */\nexport function detectStuck(\n  history: BattleRecord[],\n  ttkThresholdMs: number = 25000, // 25초\n  minRecords: number = 5\n): { isStuck: boolean; recommendationType?: string } {\n  if (history.length < minRecords) {\n    return { isStuck: false };\n  }\n\n  const recentRecords = history.slice(0, minRecords);\n  const averageTTK = calculateAverageTTK(recentRecords);\n\n  if (averageTTK > ttkThresholdMs) {\n    // 최근 스테이지 기반 추천\n    const recentStage = recentRecords[0].stage;\n    let recommendationType = 'upgrade';\n\n    if (recentStage > 100) {\n      recommendationType = 'prestige';\n    } else if (recentStage > 50) {\n      recommendationType = 'mode';\n    }\n\n    return {\n      isStuck: true,\n      recommendationType,\n    };\n  }\n\n  return { isStuck: false };\n}\n\n/**\n * 막힘 감지 기록 추가\n */\nexport function recordStuckDetection(\n  history: StuckDetectionRecord[],\n  averageTTK: number,\n  recommendationType: 'upgrade' | 'prestige' | 'mode',\n  maxRecords: number = 20\n): StuckDetectionRecord[] {\n  const newRecord: StuckDetectionRecord = {\n    detectedAt: Date.now(),\n    averageTTK,\n    recommendationType,\n  };\n\n  const updated = [newRecord, ...history].slice(0, maxRecords);\n  return updated;\n}\n\n/**\n * 막힘 감지 빈도 계산\n */\nexport function getStuckDetectionFrequency(\n  history: StuckDetectionRecord[],\n  timeWindowMs: number = 3600000 // 1시간\n): number {\n  const now = Date.now();\n  const recentDetections = history.filter(\n    (record) => now - record.detectedAt < timeWindowMs\n  );\n  return recentDetections.length;\n}\n\n/**\n * 모드 해금 여부\n */\nexport function shouldUnlockMode(\n  stage: number,\n  modeUnlockStage: number\n): boolean {\n  return stage >= modeUnlockStage;\n}\n\n/**\n * 복귀 유저 상태 업데이트\n */\nexport function updateRetentionState(\n  state: RetentionState,\n  updates: Partial<RetentionState>\n): RetentionState {\n  return {\n    ...state,\n    ...updates,\n    lastActiveAt: Date.now(),\n  };\n}\n
