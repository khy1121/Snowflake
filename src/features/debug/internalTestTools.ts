/**\n * 내부 테스트 도구\n * Sprint 10: 피드백, 진단 덤프, UGC 검증 로그\n */\n\nimport { FeedbackLog, DiagnosticDump, UGCReport } from '../../ugc/types';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * 피드백 로그 생성\n */\nexport function createFeedbackLog(\n  type: 'BUG' | 'SUGGESTION' | 'UGC_RELATED',\n  text: string,\n  attachedState?: string\n): FeedbackLog {\n  return {\n    id: uuidv4(),\n    type,\n    text: text.substring(0, 500), // 최대 500자\n    attachedState,\n    submittedAt: Date.now(),\n  };\n}\n\n/**\n * 진단 덤프 생성\n */\nexport function createDiagnosticDump(\n  stage: number,\n  gold: number,\n  companionCount: number,\n  eventState: string,\n  experimentVariant: string,\n  language: string,\n  recentLogs: string[]\n): DiagnosticDump {\n  return {\n    timestamp: Date.now(),\n    stage,\n    gold,\n    companionCount,\n    eventState,\n    experimentVariant,\n    language,\n    recentLogs: recentLogs.slice(0, 30), // 최근 30개 로그\n  };\n}\n\n/**\n * 진단 덤프를 JSON 문자열로 변환\n */\nexport function diagnosticDumpToJSON(dump: DiagnosticDump): string {\n  return JSON.stringify(dump, null, 2);\n}\n\n/**\n * 진단 덤프를 요약 문자열로 변환\n */\nexport function diagnosticDumpToSummary(dump: DiagnosticDump): string {\n  return `\n=== 진단 정보 ===\n시간: ${new Date(dump.timestamp).toLocaleString()}\n스테이지: ${dump.stage}\n골드: ${dump.gold}\n동료 수: ${dump.companionCount}\n이벤트 상태: ${dump.eventState}\n실험 그룹: ${dump.experimentVariant}\n언어: ${dump.language}\n최근 로그: ${dump.recentLogs.length}개\n  `.trim();\n}\n\n/**\n * UGC 신고 로그 생성\n */\nexport function createUGCReport(\n  scenarioId: string,\n  reason: 'PROFANITY' | 'INAPPROPRIATE' | 'FAKE_REWARD' | 'OTHER',\n  description: string\n): UGCReport {\n  return {\n    id: uuidv4(),\n    scenarioId,\n    reason,\n    description: description.substring(0, 200), // 최대 200자\n    reportedAt: Date.now(),\n  };\n}\n\n/**\n * 피드백 로그를 로컬 저장소에 저장 (시뮬레이션)\n */\nexport function saveFeedbackLocalLog(logs: FeedbackLog[]): string {\n  const json = JSON.stringify(logs, null, 2);\n  // 실제로는 AsyncStorage 또는 파일 시스템에 저장\n  return json;\n}\n\n/**\n * 피드백 로그를 클립보드에 복사할 문자열로 변환\n */\nexport function feedbackLogsToClipboard(logs: FeedbackLog[]): string {\n  return logs\n    .map(\n      (log, index) => `\n[${index + 1}] ${log.type}\n시간: ${new Date(log.submittedAt).toLocaleString()}\n내용: ${log.text}\n${log.attachedState ? `첨부 상태: ${log.attachedState}` : ''}\n    `.trim()\n    )\n    .join('\\n\\n---\\n\\n');\n}\n\n/**\n * UGC 신고 로그를 로컬 저장소에 저장 (시뮬레이션)\n */\nexport function saveUGCReportLocalLog(reports: UGCReport[]): string {\n  const json = JSON.stringify(reports, null, 2);\n  // 실제로는 AsyncStorage 또는 파일 시스템에 저장\n  return json;\n}\n\n/**\n * UGC 신고 로그를 클립보드에 복사할 문자열로 변환\n */\nexport function ugcReportsToClipboard(reports: UGCReport[]): string {\n  return reports\n    .map(\n      (report, index) => `\n[${index + 1}] 신고\n시나리오 ID: ${report.scenarioId}\n사유: ${report.reason}\n설명: ${report.description}\n시간: ${new Date(report.reportedAt).toLocaleString()}\n    `.trim()\n    )\n    .join('\\n\\n---\\n\\n');\n}\n\n/**\n * 로그 레벨\n */\nexport enum LogLevel {\n  DEBUG = 'DEBUG',\n  INFO = 'INFO',\n  WARN = 'WARN',\n  ERROR = 'ERROR',\n}\n\n/**\n * 로그 항목\n */\nexport interface LogEntry {\n  level: LogLevel;\n  message: string;\n  timestamp: number;\n  context?: Record<string, any>;\n}\n\n/**\n * 로거 (내부 테스트용)\n */\nexport class InternalLogger {\n  private logs: LogEntry[] = [];\n  private maxLogs = 100;\n\n  log(level: LogLevel, message: string, context?: Record<string, any>) {\n    const entry: LogEntry = {\n      level,\n      message,\n      timestamp: Date.now(),\n      context,\n    };\n    this.logs.push(entry);\n\n    // 최대 로그 개수 초과 시 오래된 것부터 제거\n    if (this.logs.length > this.maxLogs) {\n      this.logs.shift();\n    }\n\n    // 콘솔에도 출력\n    console.log(`[${level}] ${message}`, context);\n  }\n\n  debug(message: string, context?: Record<string, any>) {\n    this.log(LogLevel.DEBUG, message, context);\n  }\n\n  info(message: string, context?: Record<string, any>) {\n    this.log(LogLevel.INFO, message, context);\n  }\n\n  warn(message: string, context?: Record<string, any>) {\n    this.log(LogLevel.WARN, message, context);\n  }\n\n  error(message: string, context?: Record<string, any>) {\n    this.log(LogLevel.ERROR, message, context);\n  }\n\n  getLogs(): LogEntry[] {\n    return [...this.logs];\n  }\n\n  getRecentLogs(count: number = 30): string[] {\n    return this.logs\n      .slice(-count)\n      .map(log => `[${log.level}] ${log.message}`);\n  }\n\n  clear() {\n    this.logs = [];\n  }\n}\n\n// 싱글톤 인스턴스\nexport const internalLogger = new InternalLogger();\n
