/**\n * 동료 시너지 엔진\n * 동료 조합에 따른 시너지 효과 계산\n */\n\nimport { Synergy, SynergyEffect } from '../../types';\n\n/**\n * 활성 시너지 목록 계산\n */\nexport function getActiveSynergies(\n  companions: string[],\n  synergies: Synergy[]\n): Synergy[] {\n  return synergies.filter((synergy) => {\n    // 모든 필수 동료가 있는지 확인\n    return synergy.requiredCompanionIds.every((id) => companions.includes(id));\n  });\n}\n\n/**\n * 시너지 효과 적용\n */\nexport function applySynergyEffects(\n  baseStats: {\n    gold: number;\n    fragment: number;\n    hp: number;\n    atk: number;\n    attackSpeed: number;\n    critChance: number;\n    critDamage: number;\n    offline: number;\n    passXp: number;\n  },\n  activeSynergies: Synergy[]\n): typeof baseStats {\n  let stats = { ...baseStats };\n\n  for (const synergy of activeSynergies) {\n    for (const effect of synergy.effects) {\n      stats = applySynergyEffect(stats, effect);\n    }\n  }\n\n  return stats;\n}\n\n/**\n * 단일 시너지 효과 적용\n */\nexport function applySynergyEffect(\n  stats: any,\n  effect: SynergyEffect\n): any {\n  const multiplier = 1 + effect.value;\n\n  switch (effect.type) {\n    case 'gold':\n      return { ...stats, gold: stats.gold * multiplier };\n    case 'fragment':\n      return { ...stats, fragment: stats.fragment * multiplier };\n    case 'hp':\n      return { ...stats, hp: stats.hp * multiplier };\n    case 'atk':\n      return { ...stats, atk: stats.atk * multiplier };\n    case 'attackSpeed':\n      return { ...stats, attackSpeed: stats.attackSpeed * multiplier };\n    case 'critChance':\n      return { ...stats, critChance: Math.min(stats.critChance + effect.value, 1) };\n    case 'critDamage':\n      return { ...stats, critDamage: stats.critDamage * multiplier };\n    case 'offline':\n      return { ...stats, offline: stats.offline * multiplier };\n    case 'passXp':\n      return { ...stats, passXp: stats.passXp * multiplier };\n    default:\n      return stats;\n  }\n}\n\n/**\n * 시너지 조건 확인\n */\nexport function checkSynergyCondition(\n  synergy: Synergy,\n  companions: string[]\n): boolean {\n  return synergy.requiredCompanionIds.every((id) => companions.includes(id));\n}\n\n/**\n * 시너지 진행도 계산 (몇 개의 필수 동료를 가지고 있는지)\n */\nexport function calculateSynergyProgress(\n  synergy: Synergy,\n  companions: string[]\n): { current: number; required: number; percentage: number } {\n  const current = synergy.requiredCompanionIds.filter((id) => companions.includes(id)).length;\n  const required = synergy.requiredCompanionIds.length;\n  return {\n    current,\n    required,\n    percentage: Math.floor((current / required) * 100),\n  };\n}\n\n/**\n * 시너지 효과 설명 생성\n */\nexport function getSynergyEffectDescription(effect: SynergyEffect): string {\n  return effect.description || '';\n}\n\n/**\n * 시너지 추천 (다음에 얻을 수 있는 시너지)\n */\nexport function getNextSynergies(\n  companions: string[],\n  synergies: Synergy[],\n  maxRecommendations: number = 3\n): Synergy[] {\n  const incompleteSynergies = synergies\n    .filter((synergy) => !checkSynergyCondition(synergy, companions))\n    .map((synergy) => ({\n      synergy,\n      progress: calculateSynergyProgress(synergy, companions),\n    }))\n    .filter((item) => item.progress.current > 0) // 최소 1개 이상 진행된 것만\n    .sort((a, b) => b.progress.percentage - a.progress.percentage) // 진행도 높은 순\n    .slice(0, maxRecommendations)\n    .map((item) => item.synergy);\n\n  return incompleteSynergies;\n}\n\n/**\n * 시너지 통계\n */\nexport function getSynergyStats(\n  companions: string[],\n  synergies: Synergy[]\n): {\n  totalSynergies: number;\n  activeSynergies: number;\n  totalEffects: number;\n  effectTypes: Record<string, number>;\n} {\n  const active = getActiveSynergies(companions, synergies);\n  const effectTypes: Record<string, number> = {};\n\n  for (const synergy of active) {\n    for (const effect of synergy.effects) {\n      effectTypes[effect.type] = (effectTypes[effect.type] || 0) + 1;\n    }\n  }\n\n  return {\n    totalSynergies: synergies.length,\n    activeSynergies: active.length,\n    totalEffects: active.reduce((sum, s) => sum + s.effects.length, 0),\n    effectTypes,\n  };\n}\n\n/**\n * 시너지 데이터 유효성 검사\n */\nexport function validateSynergyData(synergies: Synergy[]): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  for (const synergy of synergies) {\n    if (!synergy.id) errors.push(`시너지 ID 누락: ${synergy.name}`);\n    if (!synergy.name) errors.push(`시너지 이름 누락: ${synergy.id}`);\n    if (!Array.isArray(synergy.requiredCompanionIds) || synergy.requiredCompanionIds.length === 0) {\n      errors.push(`필수 동료 누락: ${synergy.id}`);\n    }\n    if (!Array.isArray(synergy.effects) || synergy.effects.length === 0) {\n      errors.push(`시너지 효과 누락: ${synergy.id}`);\n    }\n  }\n\n  return { valid: errors.length === 0, errors };\n}\n
