/**\n * 동료 시너지(세트 효과) 엔진\n * Sprint 11: 시너지 활성 판정, 효과 적용, 상한 clamp\n */\n\nexport interface SynergyEffect {\n  type: 'goldGain' | 'fragmentsGain' | 'offlineEfficiency' | 'passXpGain' | 'cosmeticTokenBonus';\n  value: number; // 0.0 ~ 1.0 (백분율)\n  scope: 'global' | 'modes' | 'offline';\n}\n\nexport interface CompanionSynergy {\n  id: string;\n  name: string;\n  description: string;\n  requiredCompanionIds: string[];\n  effects: SynergyEffect[];\n}\n\nexport interface SynergyState {\n  activeSynergyIds: string[];\n  appliedEffects: Record<string, number>; // 효과 타입별 합산값\n  lastUpdated: number;\n}\n\n/**\n * 기본 시너지 상태 생성\n */\nexport function createDefaultSynergyState(): SynergyState {\n  return {\n    activeSynergyIds: [],\n    appliedEffects: {\n      goldGain: 0,\n      fragmentsGain: 0,\n      offlineEfficiency: 0,\n      passXpGain: 0,\n      cosmeticTokenBonus: 0,\n    },\n    lastUpdated: Date.now(),\n  };\n}\n\n/**\n * 시너지 활성 판정\n */\nexport function isActiveSynergy(\n  synergy: CompanionSynergy,\n  unlockedCompanionIds: string[]\n): boolean {\n  // 필요한 모든 동료가 해금되었는지 확인\n  return synergy.requiredCompanionIds.every(id => unlockedCompanionIds.includes(id));\n}\n\n/**\n * 활성 시너지 목록 계산\n */\nexport function calculateActiveSynergies(\n  allSynergies: CompanionSynergy[],\n  unlockedCompanionIds: string[]\n): string[] {\n  return allSynergies\n    .filter(synergy => isActiveSynergy(synergy, unlockedCompanionIds))\n    .map(synergy => synergy.id);\n}\n\n/**\n * 시너지 효과 합산 (상한 clamp 포함)\n */\nexport function calculateSynergyEffects(\n  activeSynergies: CompanionSynergy[],\n  balanceLimits: Record<string, number>\n): Record<string, number> {\n  const effects: Record<string, number> = {\n    goldGain: 0,\n    fragmentsGain: 0,\n    offlineEfficiency: 0,\n    passXpGain: 0,\n    cosmeticTokenBonus: 0,\n  };\n\n  // 모든 활성 시너지의 효과 합산\n  activeSynergies.forEach(synergy => {\n    synergy.effects.forEach(effect => {\n      effects[effect.type] = (effects[effect.type] || 0) + effect.value;\n    });\n  });\n\n  // 상한 clamp 적용\n  const clampedEffects: Record<string, number> = {};\n  Object.entries(effects).forEach(([key, value]) => {\n    const limit = balanceLimits[`${key}_max`] || 0.5;\n    clampedEffects[key] = Math.min(value, limit);\n  });\n\n  return clampedEffects;\n}\n\n/**\n * 시너지 상태 업데이트\n */\nexport function updateSynergyState(\n  allSynergies: CompanionSynergy[],\n  unlockedCompanionIds: string[],\n  balanceLimits: Record<string, number>\n): SynergyState {\n  const activeSynergyIds = calculateActiveSynergies(allSynergies, unlockedCompanionIds);\n  const activeSynergies = allSynergies.filter(s => activeSynergyIds.includes(s.id));\n  const appliedEffects = calculateSynergyEffects(activeSynergies, balanceLimits);\n\n  return {\n    activeSynergyIds,\n    appliedEffects,\n    lastUpdated: Date.now(),\n  };\n}\n\n/**\n * 시너지 효과 적용 (보상 계산)\n */\nexport function applyGoldGainSynergy(baseGold: number, synergyBonus: number): number {\n  return Math.floor(baseGold * (1 + synergyBonus));\n}\n\nexport function applyFragmentsGainSynergy(baseFragments: number, synergyBonus: number): number {\n  return Math.floor(baseFragments * (1 + synergyBonus));\n}\n\nexport function applyOfflineEfficiencySynergy(baseReward: number, synergyBonus: number): number {\n  return Math.floor(baseReward * (1 + synergyBonus));\n}\n\nexport function applyPassXpGainSynergy(baseXp: number, synergyBonus: number): number {\n  return Math.floor(baseXp * (1 + synergyBonus));\n}\n\nexport function applyCosmeticTokenBonusSynergy(baseTokens: number, synergyBonus: number): number {\n  return Math.floor(baseTokens * (1 + synergyBonus));\n}\n\n/**\n * 시너지 효과 설명 (UI용)\n */\nexport function getSynergyEffectDescription(\n  effect: SynergyEffect,\n  language: 'ko' | 'en' = 'ko'\n): string {\n  const descriptions = {\n    ko: {\n      goldGain: `골드 획득량 +${(effect.value * 100).toFixed(0)}%`,\n      fragmentsGain: `파편 획득량 +${(effect.value * 100).toFixed(0)}%`,\n      offlineEfficiency: `오프라인 효율 +${(effect.value * 100).toFixed(0)}%`,\n      passXpGain: `패스 경험치 +${(effect.value * 100).toFixed(0)}%`,\n      cosmeticTokenBonus: `코스튬 토큰 +${(effect.value * 100).toFixed(0)}%`,\n    },\n    en: {\n      goldGain: `Gold Gain +${(effect.value * 100).toFixed(0)}%`,\n      fragmentsGain: `Fragments Gain +${(effect.value * 100).toFixed(0)}%`,\n      offlineEfficiency: `Offline Efficiency +${(effect.value * 100).toFixed(0)}%`,\n      passXpGain: `Pass XP Gain +${(effect.value * 100).toFixed(0)}%`,\n      cosmeticTokenBonus: `Cosmetic Token +${(effect.value * 100).toFixed(0)}%`,\n    },\n  };\n\n  return descriptions[language][effect.type] || effect.type;\n}\n\n/**\n * 시너지 조건 설명 (UI용)\n */\nexport function getSynergyConditionDescription(\n  requiredCompanionIds: string[],\n  companionNames: Record<string, string>,\n  language: 'ko' | 'en' = 'ko'\n): string {\n  const names = requiredCompanionIds.map(id => companionNames[id] || id);\n  const joinWord = language === 'ko' ? ', ' : ', ';\n  return names.join(joinWord) + (language === 'ko' ? ' 필요' : ' required');\n}\n\n/**\n * 시너지 활성 여부 확인 (UI용)\n */\nexport function getSynergyStatus(\n  synergy: CompanionSynergy,\n  unlockedCompanionIds: string[],\n  language: 'ko' | 'en' = 'ko'\n): { isActive: boolean; status: string; missingCount: number } {\n  const missing = synergy.requiredCompanionIds.filter(id => !unlockedCompanionIds.includes(id));\n  const isActive = missing.length === 0;\n\n  const statusTexts = {\n    ko: {\n      active: '활성',\n      inactive: `${missing.length}개 필요`,\n    },\n    en: {\n      active: 'Active',\n      inactive: `${missing.length} needed`,\n    },\n  };\n\n  return {\n    isActive,\n    status: isActive ? statusTexts[language].active : statusTexts[language].inactive,\n    missingCount: missing.length,\n  };\n}\n
