/**\n * UGC 시나리오 검증 로직\n * Sprint 10: 보상 파밍, 치트, 보안 위협 방지\n */\n\nimport { UGCScenario, UGCStage, ModifierType } from './types';\n\n// 간단한 금칙어 필터 (한국어/영어)\nconst BANNED_WORDS = [\n  '욕설1', '욕설2', '욕설3', // 실제로는 더 많은 단어 포함\n  'badword1', 'badword2', // 영어 금칙어\n];\n\nconst VALID_MODIFIERS: ModifierType[] = [\n  'SHIELD_PHASE',\n  'RAGE_PHASE',\n  'FAST_ENEMY',\n  'SLOW_PLAYER',\n  'NO_CRIT',\n  'GOLD_REDUCED',\n];\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\n/**\n * 금칙어 필터링\n */\nfunction containsBannedWords(text: string): boolean {\n  const lowerText = text.toLowerCase();\n  return BANNED_WORDS.some(word => lowerText.includes(word.toLowerCase()));\n}\n\n/**\n * 문자열 길이 검증\n */\nfunction validateStringLength(text: string, min: number, max: number, fieldName: string): string[] {\n  const errors: string[] = [];\n  if (text.length < min) {\n    errors.push(`${fieldName}은(는) 최소 ${min}자 이상이어야 합니다.`);\n  }\n  if (text.length > max) {\n    errors.push(`${fieldName}은(는) 최대 ${max}자 이하여야 합니다.`);\n  }\n  return errors;\n}\n\n/**\n * 스테이지 검증\n */\nfunction validateStage(stage: UGCStage, index: number): string[] {\n  const errors: string[] = [];\n\n  // HP 배수 범위 확인\n  if (stage.hpMultiplier < 1.0 || stage.hpMultiplier > 5.0) {\n    errors.push(`스테이지 ${index}: HP 배수는 1.0~5.0 범위여야 합니다.`);\n  }\n\n  // 보상 배수 범위 확인 (기본 0, 상한 1.0)\n  if (stage.rewardMultiplier < 0.0 || stage.rewardMultiplier > 1.0) {\n    errors.push(`스테이지 ${index}: 보상 배수는 0.0~1.0 범위여야 합니다.`);\n  }\n\n  // Modifier 개수 확인 (최대 3개)\n  if (stage.modifiers.length > 3) {\n    errors.push(`스테이지 ${index}: Modifier는 최대 3개까지만 선택 가능합니다.`);\n  }\n\n  // 유효한 Modifier 확인\n  stage.modifiers.forEach(modifier => {\n    if (!VALID_MODIFIERS.includes(modifier)) {\n      errors.push(`스테이지 ${index}: 유효하지 않은 Modifier입니다.`);\n    }\n  });\n\n  return errors;\n}\n\n/**\n * 메인 검증 함수\n */\nexport function validateScenario(scenario: UGCScenario): ValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // 1. 기본 정보 검증\n  errors.push(...validateStringLength(scenario.title, 2, 24, '제목'));\n  errors.push(...validateStringLength(scenario.summary, 0, 80, '요약'));\n  errors.push(...validateStringLength(scenario.authorName, 0, 12, '작성자명'));\n\n  // 2. 금칙어 검증\n  if (containsBannedWords(scenario.title)) {\n    errors.push('제목에 부적절한 단어가 포함되어 있습니다.');\n  }\n  if (containsBannedWords(scenario.summary)) {\n    errors.push('요약에 부적절한 단어가 포함되어 있습니다.');\n  }\n  if (containsBannedWords(scenario.authorName)) {\n    errors.push('작성자명에 부적절한 단어가 포함되어 있습니다.');\n  }\n\n  // 3. 스테이지 개수 검증\n  if (scenario.stages.length < 3 || scenario.stages.length > 8) {\n    errors.push('스테이지는 3~8개 사이여야 합니다.');\n  }\n\n  // 4. 각 스테이지 검증\n  scenario.stages.forEach((stage, index) => {\n    errors.push(...validateStage(stage, index));\n  });\n\n  // 5. 대사 검증\n  if (scenario.dialogues) {\n    if (scenario.dialogues.length > 12) {\n      errors.push('대사는 최대 12개까지만 추가 가능합니다.');\n    }\n    scenario.dialogues.forEach((dialogue, index) => {\n      if (containsBannedWords(dialogue.text)) {\n        errors.push(`대사 ${index}: 부적절한 단어가 포함되어 있습니다.`);\n      }\n      if (dialogue.text.length > 200) {\n        errors.push(`대사 ${index}: 최대 200자까지만 입력 가능합니다.`);\n      }\n    });\n  }\n\n  // 6. 규칙 검증\n  if (scenario.rules.maxOfflineMultiplierAllowed !== false) {\n    errors.push('오프라인 보상 뻥튀김은 허용되지 않습니다.');\n  }\n  if (scenario.rules.rewardMode === 'CAPPED') {\n    if (scenario.rules.dailyRewardCap < 1 || scenario.rules.dailyRewardCap > 3) {\n      errors.push('일일 보상 횟수는 1~3회 범위여야 합니다.');\n    }\n  }\n\n  // 7. 보상 파밍 방지 (하드 제한)\n  const totalRewardPotential = scenario.stages.reduce((sum, stage) => {\n    return sum + stage.rewardMultiplier;\n  }, 0);\n  if (totalRewardPotential > 2.0) {\n    errors.push('의뢰의 총 보상이 너무 많습니다. 보상 배수를 낮춰주세요.');\n  }\n\n  // 8. Checksum 검증 (기본값 체크)\n  if (!scenario.checksum || scenario.checksum.length === 0) {\n    warnings.push('체크섬이 없습니다. 무결성 검증이 불가능할 수 있습니다.');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n/**\n * 페이로드 크기 검증 (보안)\n */\nexport function validatePayloadSize(jsonString: string, maxSizeKB: number = 100): boolean {\n  const sizeKB = new TextEncoder().encode(jsonString).length / 1024;\n  return sizeKB <= maxSizeKB;\n}\n\n/**\n * Checksum 생성 (간단한 해시)\n */\nexport function generateChecksum(scenario: Omit<UGCScenario, 'checksum'>): string {\n  const data = JSON.stringify(scenario);\n  let hash = 0;\n  for (let i = 0; i < data.length; i++) {\n    const char = data.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return Math.abs(hash).toString(16);\n}\n\n/**\n * Checksum 검증\n */\nexport function verifyChecksum(scenario: UGCScenario): boolean {\n  const { checksum, ...rest } = scenario;\n  const calculatedChecksum = generateChecksum(rest);\n  return checksum === calculatedChecksum;\n}\n
